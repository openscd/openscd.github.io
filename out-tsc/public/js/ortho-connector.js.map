{"version":3,"file":"ortho-connector.js","sourceRoot":"","sources":["../../../public/js/ortho-connector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Orthogonal Connector Router\n *   - Given two rectangles and their connection points,\n *     returns the path for an orthogonal connector.\n *\n * https://jose.page\n * 2020\n */\n\ntype BasicCardinalPoint = 'n' | 'e' | 's' | 'w';\ntype Direction = 'v' | 'h';\nexport type Side = 'top' | 'right' | 'bottom' | 'left';\ntype BendDirection = BasicCardinalPoint | 'unknown' | 'none';\n\n/**\n * A point in space\n */\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n/**\n * A size tuple\n */\ninterface Size {\n  width: number;\n  height: number;\n}\n\n/**\n * A line between two points\n */\ninterface Line {\n  a: Point;\n  b: Point;\n}\n\n/**\n * Represents a Rectangle by location and size\n */\ninterface Rect extends Size {\n  left: number;\n  top: number;\n}\n\n/**\n * Represents a connection point on a routing request\n */\ninterface ConnectorPoint {\n  shape: Rect;\n  side: Side;\n  distance: number;\n}\n\n/**\n * Byproduct data emitted by the routing algorithm\n */\ninterface OrthogonalConnectorByproduct {\n  hRulers: number[];\n  vRulers: number[];\n  spots: Point[];\n  grid: Rectangle[];\n  connections: Line[];\n}\n\n/**\n * Routing request data\n */\ninterface OrthogonalConnectorOpts {\n  pointA: ConnectorPoint;\n  pointB: ConnectorPoint;\n  shapeMargin: number;\n  globalBoundsMargin: number;\n  globalBounds: Rect;\n}\n\n/**\n * Utility Point creator\n * @param x\n * @param y\n */\nfunction makePt(x: number, y: number): Point {\n  return { x, y };\n}\n\n/**\n * Computes distance between two points\n * @param a\n * @param b\n */\nfunction distance(a: Point, b: Point): number {\n  return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n}\n\n/**\n * Abstracts a Rectangle and adds geometric utilities\n */\nclass Rectangle {\n  static get empty(): Rectangle {\n    return new Rectangle(0, 0, 0, 0);\n  }\n\n  static fromRect(r: Rect): Rectangle {\n    return new Rectangle(r.left, r.top, r.width, r.height);\n  }\n\n  static fromLTRB(\n    left: number,\n    top: number,\n    right: number,\n    bottom: number\n  ): Rectangle {\n    return new Rectangle(left, top, right - left, bottom - top);\n  }\n\n  constructor(\n    readonly left: number,\n    readonly top: number,\n    readonly width: number,\n    readonly height: number\n  ) {}\n\n  contains(p: Point): boolean {\n    return (\n      p.x >= this.left &&\n      p.x <= this.right &&\n      p.y >= this.top &&\n      p.y <= this.bottom\n    );\n  }\n\n  inflate(horizontal: number, vertical: number): Rectangle {\n    return Rectangle.fromLTRB(\n      this.left - horizontal,\n      this.top - vertical,\n      this.right + horizontal,\n      this.bottom + vertical\n    );\n  }\n\n  intersects(rectangle: Rectangle): boolean {\n    const thisX = this.left;\n    const thisY = this.top;\n    const thisW = this.width;\n    const thisH = this.height;\n    const rectX = rectangle.left;\n    const rectY = rectangle.top;\n    const rectW = rectangle.width;\n    const rectH = rectangle.height;\n    return (\n      rectX < thisX + thisW &&\n      thisX < rectX + rectW &&\n      rectY < thisY + thisH &&\n      thisY < rectY + rectH\n    );\n  }\n\n  union(r: Rectangle): Rectangle {\n    const x = [this.left, this.right, r.left, r.right];\n    const y = [this.top, this.bottom, r.top, r.bottom];\n    return Rectangle.fromLTRB(\n      Math.min(...x),\n      Math.min(...y),\n      Math.max(...x),\n      Math.max(...y)\n    );\n  }\n\n  get center(): Point {\n    return {\n      x: this.left + this.width / 2,\n      y: this.top + this.height / 2,\n    };\n  }\n\n  get right(): number {\n    return this.left + this.width;\n  }\n\n  get bottom(): number {\n    return this.top + this.height;\n  }\n\n  get location(): Point {\n    return makePt(this.left, this.top);\n  }\n\n  get northEast(): Point {\n    return { x: this.right, y: this.top };\n  }\n\n  get southEast(): Point {\n    return { x: this.right, y: this.bottom };\n  }\n\n  get southWest(): Point {\n    return { x: this.left, y: this.bottom };\n  }\n\n  get northWest(): Point {\n    return { x: this.left, y: this.top };\n  }\n\n  get east(): Point {\n    return makePt(this.right, this.center.y);\n  }\n\n  get north(): Point {\n    return makePt(this.center.x, this.top);\n  }\n\n  get south(): Point {\n    return makePt(this.center.x, this.bottom);\n  }\n\n  get west(): Point {\n    return makePt(this.left, this.center.y);\n  }\n\n  get size(): Size {\n    return { width: this.width, height: this.height };\n  }\n}\n\n/**\n * Represents a node in a graph, whose data is a Point\n */\nclass PointNode {\n  public distance = Number.MAX_SAFE_INTEGER;\n  public shortestPath: PointNode[] = [];\n  public adjacentNodes: Map<PointNode, number> = new Map();\n  constructor(public data: Point) {}\n}\n\n/***\n * Represents a Graph of Point nodes\n */\nclass PointGraph {\n  private index: { [x: string]: { [y: string]: PointNode } } = {};\n\n  add(p: Point) {\n    const { x, y } = p;\n    const xs = x.toString(),\n      ys = y.toString();\n\n    if (!(xs in this.index)) {\n      this.index[xs] = {};\n    }\n    if (!(ys in this.index[xs])) {\n      this.index[xs][ys] = new PointNode(p);\n    }\n  }\n\n  private getLowestDistanceNode(unsettledNodes: Set<PointNode>): PointNode {\n    let lowestDistanceNode: PointNode | null = null;\n    let lowestDistance = Number.MAX_SAFE_INTEGER;\n    for (const node of unsettledNodes) {\n      const nodeDistance = node.distance;\n      if (nodeDistance < lowestDistance) {\n        lowestDistance = nodeDistance;\n        lowestDistanceNode = node;\n      }\n    }\n    return lowestDistanceNode!;\n  }\n\n  private inferPathDirection(node: PointNode): Direction | null {\n    if (node.shortestPath.length == 0) {\n      return null;\n    }\n\n    return this.directionOfNodes(\n      node.shortestPath[node.shortestPath.length - 1],\n      node\n    );\n  }\n\n  calculateShortestPathFromSource(\n    graph: PointGraph,\n    source: PointNode\n  ): PointGraph {\n    source.distance = 0;\n\n    const settledNodes: Set<PointNode> = new Set();\n    const unsettledNodes: Set<PointNode> = new Set();\n\n    unsettledNodes.add(source);\n\n    while (unsettledNodes.size != 0) {\n      const currentNode = this.getLowestDistanceNode(unsettledNodes);\n      unsettledNodes.delete(currentNode);\n\n      for (const [adjacentNode, edgeWeight] of currentNode.adjacentNodes) {\n        if (!settledNodes.has(adjacentNode)) {\n          this.calculateMinimumDistance(adjacentNode, edgeWeight, currentNode);\n          unsettledNodes.add(adjacentNode);\n        }\n      }\n      settledNodes.add(currentNode);\n    }\n\n    return graph;\n  }\n\n  private calculateMinimumDistance(\n    evaluationNode: PointNode,\n    edgeWeigh: number,\n    sourceNode: PointNode\n  ) {\n    const sourceDistance = sourceNode.distance;\n    const comingDirection = this.inferPathDirection(sourceNode);\n    const goingDirection = this.directionOfNodes(sourceNode, evaluationNode);\n    const changingDirection =\n      comingDirection && goingDirection && comingDirection != goingDirection;\n    const extraWeigh = changingDirection ? Math.pow(edgeWeigh + 1, 2) : 0;\n\n    if (sourceDistance + edgeWeigh + extraWeigh < evaluationNode.distance) {\n      evaluationNode.distance = sourceDistance + edgeWeigh + extraWeigh;\n      const shortestPath: PointNode[] = [...sourceNode.shortestPath];\n      shortestPath.push(sourceNode);\n      evaluationNode.shortestPath = shortestPath;\n    }\n  }\n\n  private directionOf(a: Point, b: Point): Direction | null {\n    if (a.x === b.x) {\n      return 'h';\n    } else if (a.y === b.y) {\n      return 'v';\n    } else {\n      return null;\n    }\n  }\n\n  private directionOfNodes(a: PointNode, b: PointNode): Direction | null {\n    return this.directionOf(a.data, b.data);\n  }\n\n  connect(a: Point, b: Point) {\n    const nodeA = this.get(a);\n    const nodeB = this.get(b);\n\n    if (!nodeA || !nodeB) {\n      throw new Error(`A point was not found`);\n    }\n\n    nodeA.adjacentNodes.set(nodeB, distance(a, b));\n  }\n\n  has(p: Point): boolean {\n    const { x, y } = p;\n    const xs = x.toString(),\n      ys = y.toString();\n    return xs in this.index && ys in this.index[xs];\n  }\n\n  get(p: Point): PointNode | null {\n    const { x, y } = p;\n    const xs = x.toString(),\n      ys = y.toString();\n\n    if (xs in this.index && ys in this.index[xs]) {\n      return this.index[xs][ys];\n    }\n\n    return null;\n  }\n}\n\n/**\n * Gets the actual point of the connector based on the distance parameter\n * @param p\n */\nfunction computePt(p: ConnectorPoint): Point {\n  const b = Rectangle.fromRect(p.shape);\n  switch (p.side) {\n    case 'bottom':\n      return makePt(b.left + b.width * p.distance, b.bottom);\n    case 'top':\n      return makePt(b.left + b.width * p.distance, b.top);\n    case 'left':\n      return makePt(b.left, b.top + b.height * p.distance);\n    case 'right':\n      return makePt(b.right, b.top + b.height * p.distance);\n  }\n}\n\n/**\n * Extrudes the connector point by margin depending on it's side\n * @param cp\n * @param margin\n */\nfunction extrudeCp(cp: ConnectorPoint, margin: number): Point {\n  const { x, y } = computePt(cp);\n  switch (cp.side) {\n    case 'top':\n      return makePt(x, y - margin);\n    case 'right':\n      return makePt(x + margin, y);\n    case 'bottom':\n      return makePt(x, y + margin);\n    case 'left':\n      return makePt(x - margin, y);\n  }\n}\n\n/**\n * Returns flag indicating if the side belongs on a vertical axis\n * @param side\n */\nfunction isVerticalSide(side: Side): boolean {\n  return side == 'top' || side == 'bottom';\n}\n\n/**\n * Creates a grid of rectangles from the specified set of rulers, contained on the specified bounds\n * @param verticals\n * @param horizontals\n * @param bounds\n */\nfunction rulersToGrid(\n  verticals: number[],\n  horizontals: number[],\n  bounds: Rectangle\n): Grid {\n  const result: Grid = new Grid();\n\n  verticals.sort((a, b) => a - b);\n  horizontals.sort((a, b) => a - b);\n\n  let lastX = bounds.left;\n  let lastY = bounds.top;\n  let column = 0;\n  let row = 0;\n\n  for (const y of horizontals) {\n    for (const x of verticals) {\n      result.set(row, column++, Rectangle.fromLTRB(lastX, lastY, x, y));\n      lastX = x;\n    }\n\n    // Last cell of the row\n    result.set(row, column, Rectangle.fromLTRB(lastX, lastY, bounds.right, y));\n    lastX = bounds.left;\n    lastY = y;\n    column = 0;\n    row++;\n  }\n\n  lastX = bounds.left;\n\n  // Last fow of cells\n  for (const x of verticals) {\n    result.set(\n      row,\n      column++,\n      Rectangle.fromLTRB(lastX, lastY, x, bounds.bottom)\n    );\n    lastX = x;\n  }\n\n  // Last cell of last row\n  result.set(\n    row,\n    column,\n    Rectangle.fromLTRB(lastX, lastY, bounds.right, bounds.bottom)\n  );\n\n  return result;\n}\n\n/**\n * Returns an array without repeated points\n * @param points\n */\nfunction reducePoints(points: Point[]): Point[] {\n  const result: Point[] = [];\n  const map = new Map<number, number[]>();\n\n  points.forEach(p => {\n    const { x, y } = p;\n    const arr: number[] = map.get(y) || map.set(y, []).get(y)!;\n\n    if (arr.indexOf(x) < 0) {\n      arr.push(x);\n    }\n  });\n\n  for (const [y, xs] of map) {\n    for (const x of xs) {\n      result.push(makePt(x, y));\n    }\n  }\n\n  return result;\n}\n\n/**\n * Returns a set of spots generated from the grid, avoiding colliding spots with specified obstacles\n * @param grid\n * @param obstacles\n */\nfunction gridToSpots(grid: Grid, obstacles: Rectangle[]): Point[] {\n  const obstacleCollision = (p: Point) =>\n    obstacles.filter(o => o.contains(p)).length > 0;\n\n  const gridPoints: Point[] = [];\n\n  for (const [row, data] of grid.data) {\n    const firstRow = row == 0;\n    const lastRow = row == grid.rows - 1;\n\n    for (const [col, r] of data) {\n      const firstCol = col == 0;\n      const lastCol = col == grid.columns - 1;\n      const nw = firstCol && firstRow;\n      const ne = firstRow && lastCol;\n      const se = lastRow && lastCol;\n      const sw = lastRow && firstCol;\n\n      if (nw || ne || se || sw) {\n        gridPoints.push(r.northWest, r.northEast, r.southWest, r.southEast);\n      } else if (firstRow) {\n        gridPoints.push(r.northWest, r.north, r.northEast);\n      } else if (lastRow) {\n        gridPoints.push(r.southEast, r.south, r.southWest);\n      } else if (firstCol) {\n        gridPoints.push(r.northWest, r.west, r.southWest);\n      } else if (lastCol) {\n        gridPoints.push(r.northEast, r.east, r.southEast);\n      } else {\n        gridPoints.push(\n          r.northWest,\n          r.north,\n          r.northEast,\n          r.east,\n          r.southEast,\n          r.south,\n          r.southWest,\n          r.west,\n          r.center\n        );\n      }\n    }\n  }\n\n  // for(const r of grid) {\n  //     gridPoints.push(\n  //         r.northWest, r.north, r.northEast, r.east,\n  //         r.southEast, r.south, r.southWest, r.west, r.center);\n  // }\n\n  // Reduce repeated points and filter out those who touch shapes\n  return reducePoints(gridPoints).filter(p => !obstacleCollision(p));\n}\n\n/**\n * Creates a graph connecting the specified points orthogonally\n * @param spots\n */\nfunction createGraph(spots: Point[]): {\n  graph: PointGraph;\n  connections: Line[];\n} {\n  const hotXs: number[] = [];\n  const hotYs: number[] = [];\n  const graph = new PointGraph();\n  const connections: Line[] = [];\n\n  spots.forEach(p => {\n    const { x, y } = p;\n    if (hotXs.indexOf(x) < 0) hotXs.push(x);\n    if (hotYs.indexOf(y) < 0) hotYs.push(y);\n    graph.add(p);\n  });\n\n  hotXs.sort((a, b) => a - b);\n  hotYs.sort((a, b) => a - b);\n\n  const inHotIndex = (p: Point): boolean => graph.has(p);\n\n  for (let i = 0; i < hotYs.length; i++) {\n    for (let j = 0; j < hotXs.length; j++) {\n      const b = makePt(hotXs[j], hotYs[i]);\n\n      if (!inHotIndex(b)) continue;\n\n      if (j > 0) {\n        const a = makePt(hotXs[j - 1], hotYs[i]);\n\n        if (inHotIndex(a)) {\n          graph.connect(a, b);\n          graph.connect(b, a);\n          connections.push({ a, b });\n        }\n      }\n\n      if (i > 0) {\n        const a = makePt(hotXs[j], hotYs[i - 1]);\n\n        if (inHotIndex(a)) {\n          graph.connect(a, b);\n          graph.connect(b, a);\n          connections.push({ a, b });\n        }\n      }\n    }\n  }\n\n  return { graph, connections };\n}\n\n/**\n * Solves the shotest path for the origin-destination path of the graph\n * @param graph\n * @param origin\n * @param destination\n */\nfunction shortestPath(\n  graph: PointGraph,\n  origin: Point,\n  destination: Point\n): Point[] {\n  const originNode = graph.get(origin);\n  const destinationNode = graph.get(destination);\n\n  if (!originNode) {\n    throw new Error(`Origin node {${origin.x},${origin.y}} not found`);\n  }\n\n  if (!destinationNode) {\n    throw new Error(`Origin node {${origin.x},${origin.y}} not found`);\n  }\n\n  graph.calculateShortestPathFromSource(graph, originNode);\n\n  return destinationNode.shortestPath.map(n => n.data);\n}\n\n/**\n * Given two segments represented by 3 points,\n * determines if the second segment bends on an orthogonal direction or not, and which.\n *\n * @param a\n * @param b\n * @param c\n * @return Bend direction, unknown if not orthogonal or 'none' if straight line\n */\nfunction getBend(a: Point, b: Point, c: Point): BendDirection {\n  const equalX = a.x === b.x && b.x === c.x;\n  const equalY = a.y === b.y && b.y === c.y;\n  const segment1Horizontal = a.y === b.y;\n  const segment1Vertical = a.x === b.x;\n  const segment2Horizontal = b.y === c.y;\n  const segment2Vertical = b.x === c.x;\n\n  if (equalX || equalY) {\n    return 'none';\n  }\n\n  if (\n    !(segment1Vertical || segment1Horizontal) ||\n    !(segment2Vertical || segment2Horizontal)\n  ) {\n    return 'unknown';\n  }\n\n  if (segment1Horizontal && segment2Vertical) {\n    return c.y > b.y ? 's' : 'n';\n  } else if (segment1Vertical && segment2Horizontal) {\n    return c.x > b.x ? 'e' : 'w';\n  }\n\n  throw new Error('Nope');\n}\n\n/**\n * Simplifies the path by removing unnecessary points, based on orthogonal pathways\n * @param points\n */\nfunction simplifyPath(points: Point[]): Point[] {\n  if (points.length <= 2) {\n    return points;\n  }\n\n  const r: Point[] = [points[0]];\n  for (let i = 1; i < points.length; i++) {\n    const cur = points[i];\n\n    if (i === points.length - 1) {\n      r.push(cur);\n      break;\n    }\n\n    const prev = points[i - 1];\n    const next = points[i + 1];\n    const bend = getBend(prev, cur, next);\n\n    if (bend !== 'none') {\n      r.push(cur);\n    }\n  }\n  return r;\n}\n\n/**\n * Helps create the grid portion of the algorithm\n */\nclass Grid {\n  private _rows = 0;\n  private _cols = 0;\n\n  readonly data: Map<number, Map<number, Rectangle>> = new Map();\n\n  //constructor() {}\n\n  set(row: number, column: number, rectangle: Rectangle) {\n    this._rows = Math.max(this.rows, row + 1);\n    this._cols = Math.max(this.columns, column + 1);\n\n    const rowMap: Map<number, Rectangle> =\n      this.data.get(row) || this.data.set(row, new Map()).get(row)!;\n\n    rowMap.set(column, rectangle);\n  }\n\n  get(row: number, column: number): Rectangle | null {\n    const rowMap = this.data.get(row);\n\n    if (rowMap) {\n      return rowMap.get(column) || null;\n    }\n\n    return null;\n  }\n\n  rectangles(): Rectangle[] {\n    const r: Rectangle[] = [];\n\n    for (const [_, data] of this.data) {\n      for (const [_, rect] of data) {\n        r.push(rect);\n      }\n    }\n\n    return r;\n  }\n\n  get columns(): number {\n    return this._cols;\n  }\n\n  get rows(): number {\n    return this._rows;\n  }\n}\n\n/**\n * Main logic wrapped in a class to hold a space for potential future functionallity\n */\nexport class OrthogonalConnector {\n  static readonly byproduct: OrthogonalConnectorByproduct = {\n    hRulers: [],\n    vRulers: [],\n    spots: [],\n    grid: [],\n    connections: [],\n  };\n\n  static route(opts: OrthogonalConnectorOpts): Point[] {\n    const { pointA, pointB, globalBoundsMargin } = opts;\n    const spots: Point[] = [];\n    const verticals: number[] = [];\n    const horizontals: number[] = [];\n    const sideA = pointA.side,\n      sideAVertical = isVerticalSide(sideA);\n    const sideB = pointB.side,\n      sideBVertical = isVerticalSide(sideB);\n    const originA = computePt(pointA);\n    const originB = computePt(pointB);\n    const shapeA = Rectangle.fromRect(pointA.shape);\n    const shapeB = Rectangle.fromRect(pointB.shape);\n    const bigBounds = Rectangle.fromRect(opts.globalBounds);\n    let shapeMargin = opts.shapeMargin;\n    let inflatedA = shapeA.inflate(shapeMargin, shapeMargin);\n    let inflatedB = shapeB.inflate(shapeMargin, shapeMargin);\n\n    // Check bounding boxes collision\n    if (inflatedA.intersects(inflatedB)) {\n      shapeMargin = 0;\n      inflatedA = shapeA;\n      inflatedB = shapeB;\n    }\n\n    const inflatedBounds = inflatedA\n      .union(inflatedB)\n      .inflate(globalBoundsMargin, globalBoundsMargin);\n\n    // Curated bounds to stick to\n    const bounds = Rectangle.fromLTRB(\n      Math.max(inflatedBounds.left, bigBounds.left),\n      Math.max(inflatedBounds.top, bigBounds.top),\n      Math.min(inflatedBounds.right, bigBounds.right),\n      Math.min(inflatedBounds.bottom, bigBounds.bottom)\n    );\n\n    // Add edges to rulers\n    for (const b of [inflatedA, inflatedB]) {\n      verticals.push(b.left);\n      verticals.push(b.right);\n      horizontals.push(b.top);\n      horizontals.push(b.bottom);\n    }\n\n    // Rulers at origins of shapes\n    (sideAVertical ? verticals : horizontals).push(\n      sideAVertical ? originA.x : originA.y\n    );\n    (sideBVertical ? verticals : horizontals).push(\n      sideBVertical ? originB.x : originB.y\n    );\n\n    // Points of shape antennas\n    for (const connectorPt of [pointA, pointB]) {\n      const p = computePt(connectorPt);\n      const add = (dx: number, dy: number) =>\n        spots.push(makePt(p.x + dx, p.y + dy));\n\n      switch (connectorPt.side) {\n        case 'top':\n          add(0, -shapeMargin);\n          break;\n        case 'right':\n          add(shapeMargin, 0);\n          break;\n        case 'bottom':\n          add(0, shapeMargin);\n          break;\n        case 'left':\n          add(-shapeMargin, 0);\n          break;\n      }\n    }\n\n    // Sort rulers\n    verticals.sort((a, b) => a - b);\n    horizontals.sort((a, b) => a - b);\n\n    // Create grid\n    const grid = rulersToGrid(verticals, horizontals, bounds);\n    const gridPoints = gridToSpots(grid, [inflatedA, inflatedB]);\n\n    // Add to spots\n    spots.push(...gridPoints);\n\n    // Create graph\n    const { graph, connections } = createGraph(spots);\n\n    // Origin and destination by extruding antennas\n    const origin = extrudeCp(pointA, shapeMargin);\n    const destination = extrudeCp(pointB, shapeMargin);\n\n    const start = computePt(pointA);\n    const end = computePt(pointB);\n\n    this.byproduct.spots = spots;\n    this.byproduct.vRulers = verticals;\n    this.byproduct.hRulers = horizontals;\n    this.byproduct.grid = grid.rectangles();\n    this.byproduct.connections = connections;\n\n    const path = shortestPath(graph, origin, destination);\n\n    if (path.length > 0) {\n      return simplifyPath([\n        start,\n        ...shortestPath(graph, origin, destination),\n        end,\n      ]);\n    } else {\n      return [];\n    }\n  }\n}\n"]}